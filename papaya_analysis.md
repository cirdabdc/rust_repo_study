# Papaya å¹¶å‘å“ˆå¸Œè¡¨æºç åˆ†æä¸æ€§èƒ½è¯„ä»·

## é¡¹ç›®æ¦‚è¿°

**Papaya** æ˜¯ä¸€ä¸ªä¸“ä¸ºè¯»å¯†é›†å‹å·¥ä½œè´Ÿè½½ä¼˜åŒ–çš„é«˜æ€§èƒ½å¹¶å‘å“ˆå¸Œè¡¨å®ç°ï¼Œé‡‡ç”¨ Rust ç¼–å†™ã€‚å®ƒæä¾›äº†æ— é”çš„ API è®¾è®¡ï¼Œé¿å…äº†æ­»é”é—®é¢˜ï¼ŒåŒæ—¶ä¿æŒäº†æé«˜çš„è¯»å–æ€§èƒ½å’Œå¯é¢„æµ‹çš„å»¶è¿Ÿç‰¹æ€§ã€‚

**é¡¹ç›®ä¿¡æ¯**ï¼š
- **ä»“åº“**: https://github.com/ibraheemdev/papaya
- **ç‰ˆæœ¬**: 0.2.3
- **ä½œè€…**: Ibraheem Ahmed
- **è®¸å¯**: MIT
- **æ ¸å¿ƒä¾èµ–**: seize (åƒåœ¾å›æ”¶), equivalent (é”®æ¯”è¾ƒ)

## æ ¸å¿ƒå®ç°æœºåˆ¶

### 1. æ•´ä½“æ¶æ„è®¾è®¡

Papaya é‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼š

```
papaya/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # å…¬å…± API å¯¼å‡º
â”‚   â”œâ”€â”€ map.rs           # HashMap ç”¨æˆ·æ¥å£å±‚
â”‚   â”œâ”€â”€ set.rs           # HashSet å°è£…
â”‚   â””â”€â”€ raw/
â”‚       â”œâ”€â”€ mod.rs       # æ ¸å¿ƒå¹¶å‘é€»è¾‘
â”‚       â”œâ”€â”€ alloc.rs     # è¡¨å†…å­˜åˆ†é…
â”‚       â”œâ”€â”€ probe.rs     # æ¢æµ‹åºåˆ—ç®—æ³•
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ counter.rs   # åˆ†ç‰‡è®¡æ•°å™¨
â”‚           â”œâ”€â”€ parker.rs    # æ¡ä»¶ç­‰å¾…
â”‚           â”œâ”€â”€ stack.rs     # æ— é”æ ˆ
â”‚           â””â”€â”€ tagged.rs    # æŒ‡é’ˆæ ‡è®°å·¥å…·
```

**è®¾è®¡å±‚æ¬¡**ï¼š
- **å¤–å±‚ API** (`map.rs`)ï¼šæä¾›ç”¨æˆ·å‹å¥½çš„ HashMap æ¥å£
- **åŸå§‹å®ç°å±‚** (`raw/mod.rs`)ï¼šåŒ…å«æ— é”å¹¶å‘é€»è¾‘
- **å†…å­˜ç®¡ç†** (`raw/alloc.rs`)ï¼šè‡ªå®šä¹‰è¡¨åˆ†é…å’Œå¸ƒå±€
- **å·¥å…·å±‚** (`raw/utils/`)ï¼šè¾…åŠ©æ•°æ®ç»“æ„

### 2. æ•°æ®ç»“æ„å¸ƒå±€

#### 2.1 è¡¨ç»“æ„ (Table Layout)

```rust
#[repr(C)]
struct TableLayout<T> {
    /// ç´¢å¼•æ©ç ï¼ˆå®¹é‡-1ï¼Œç”¨äºå¿«é€Ÿå–æ¨¡ï¼‰
    mask: usize,

    /// æœ€å¤§æ¢æµ‹é•¿åº¦é™åˆ¶
    limit: usize,

    /// æ‰©å®¹çŠ¶æ€ç®¡ç†
    state: State<T>,

    /// å…ƒæ•°æ®æ•°ç»„ï¼ˆå­˜å‚¨ hash çš„ç¬¬äºŒéƒ¨åˆ†ï¼Œç”¨äºå¿«é€Ÿè¿‡æ»¤ï¼‰
    meta: [AtomicU8; 0],

    /// Entry æŒ‡é’ˆæ•°ç»„
    entries: [AtomicPtr<T>; 0],
}
```

**å…³é”®ç‰¹æ€§**ï¼š
- âœ… **å•æ¬¡å†…å­˜åˆ†é…**ï¼šæ•´ä¸ªè¡¨ï¼ˆstate + meta + entriesï¼‰åœ¨ä¸€æ¬¡ `alloc` ä¸­å®Œæˆ
- âœ… **2 çš„å¹‚æ¬¡å®¹é‡**ï¼šä¾¿äºä½è¿ç®—ä¼˜åŒ–ï¼ˆ`hash & mask` ä»£æ›¿ `hash % capacity`ï¼‰
- âœ… **å…ƒæ•°æ®æ•°ç»„åŠ é€Ÿ**ï¼šå…ˆæ£€æŸ¥ 1 å­—èŠ‚çš„ metaï¼ŒåŒ¹é…åå†åŠ è½½ 8 å­—èŠ‚çš„æŒ‡é’ˆ

**å†…å­˜å¸ƒå±€ç¤ºæ„**ï¼š
```
[TableLayout Header][Meta Array (len bytes)][Entry Pointers (len * 8 bytes)]
```

#### 2.2 Entry ç»“æ„ä¸æŒ‡é’ˆæ ‡è®°

```rust
#[repr(C, align(8))]  // å¼ºåˆ¶ 8 å­—èŠ‚å¯¹é½ï¼Œä¿è¯ä½ 3 ä½ä¸º 0
pub struct Entry<K, V> {
    pub key: K,
    pub value: V,
}
```

**æŒ‡é’ˆæ ‡è®°æŠ€æœ¯**ï¼ˆåˆ©ç”¨ 8 å­—èŠ‚å¯¹é½çš„ä½ 3 ä½ï¼‰ï¼š

| æ ‡è®°ä½ | åç§° | å«ä¹‰ | ä½¿ç”¨åœºæ™¯ |
|--------|------|------|----------|
| `0b001` | `COPYING` | æ­£åœ¨å¤åˆ¶åˆ°æ–°è¡¨ | é˜»æ­¢å¹¶å‘ä¿®æ”¹ |
| `0b010` | `COPIED` | å·²å¤åˆ¶åˆ°æ–°è¡¨ | è¯»æ“ä½œéœ€è½¬å‘æ–°è¡¨ |
| `0b100` | `BORROWED` | ä»æ—§è¡¨å€Ÿç”¨ | å»¶è¿Ÿå†…å­˜å›æ”¶ |

**ç¤ºä¾‹**ï¼š
```rust
// åŸå§‹æŒ‡é’ˆ: 0x7fff12345678
// æ ‡è®° COPYING: 0x7fff12345679 (æœ€åä¸€ä½å˜ä¸º 1)
// è§£åŒ…æ—¶ä½¿ç”¨æ©ç : ptr & !0b111
```

#### 2.3 æ‰©å®¹çŠ¶æ€ (State)

```rust
pub struct State<T> {
    /// ä¸‹ä¸€ä¸ªè¡¨çš„æŒ‡é’ˆï¼ˆæ‰©å®¹ç›®æ ‡ï¼‰
    pub next: AtomicPtr<RawTable<T>>,

    /// åˆ†é…æ–°è¡¨çš„äº’æ–¥é”
    pub allocating: Mutex<()>,

    /// å·²å®Œæˆå¤åˆ¶çš„æ¡ç›®æ•°
    pub copied: AtomicUsize,

    /// å·²å£°æ˜è¦å¤åˆ¶çš„æ¡ç›®æ•°ï¼ˆ>= copiedï¼‰
    pub claim: AtomicUsize,

    /// æ‰©å®¹çŠ¶æ€ï¼šPENDING/ABORTED/PROMOTED
    pub status: AtomicU8,

    /// çº¿ç¨‹ç­‰å¾…æœºåˆ¶
    pub parker: Parker,

    /// å»¶è¿Ÿå›æ”¶çš„æ¡ç›®æ ˆ
    pub deferred: Stack<*mut T>,
}
```

### 3. è¯»æ“ä½œå®ç°

**æ ¸å¿ƒå‡½æ•°ç­¾å**ï¼š
```rust
pub fn get<'g, Q>(&self, key: &Q, guard: &'g impl VerifiedGuard)
    -> Option<(&'g K, &'g V)>
where
    Q: Equivalent<K> + Hash + ?Sized,
```

**æŸ¥æ‰¾æµç¨‹**ï¼ˆä½äº `raw/mod.rs:309-392`ï¼‰ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. åŠ è½½æ ¹è¡¨                                              â”‚
â”‚    let table = guard.protect(&self.table, Acquire)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. è®¡ç®—äºŒæ¬¡å“ˆå¸Œ                                          â”‚
â”‚    let (h1, h2) = self.hash(key)                        â”‚
â”‚    - h1: ç”¨äºç´¢å¼•è®¡ç®— (i = h1 & mask)                   â”‚
â”‚    - h2: ç”¨äºå…ƒæ•°æ®å¿«é€Ÿè¿‡æ»¤                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. äºŒæ¬¡æ¢æµ‹åºåˆ—                                          â”‚
â”‚    probe.i = (h1 & mask)                                â”‚
â”‚    loop:                                                â”‚
â”‚      if probe.len > limit: goto step 6                  â”‚
â”‚      ...                                                â”‚
â”‚      probe.next(mask)  // i += probe.len                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. ä¸¤çº§è¿‡æ»¤æ£€æŸ¥                                          â”‚
â”‚    a) å…ƒæ•°æ®è¿‡æ»¤ï¼š                                       â”‚
â”‚       let meta = table.meta(i).load(Acquire)            â”‚
â”‚       if meta != h2: continue probe                     â”‚
â”‚                                                         â”‚
â”‚    b) åŠ è½½å®Œæ•´ Entryï¼š                                   â”‚
â”‚       let entry = guard.protect(table.entry(i), Acquire)â”‚
â”‚       if entry.is_null(): continue probe                â”‚
â”‚       if key == entry.key: goto step 5                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. æ£€æŸ¥ COPIED æ ‡è®°                                      â”‚
â”‚    if entry.tag() & COPIED != 0:                        â”‚
â”‚      table = table.next_table()  // è½¬å‘æ–°è¡¨             â”‚
â”‚      goto step 3                                        â”‚
â”‚    else:                                                â”‚
â”‚      return Some((&entry.key, &entry.value))            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. æ¢æµ‹å¤±è´¥å¤„ç†                                          â”‚
â”‚    if meta == EMPTY:                                    â”‚
â”‚      return None  // ç¡®å®šä¸å­˜åœ¨                          â”‚
â”‚    if is_incremental && has_next_table:                 â”‚
â”‚      table = next_table; goto step 3                    â”‚
â”‚    else:                                                â”‚
â”‚      return None                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æ€§èƒ½ä¼˜åŒ–ç‚¹**ï¼š

1. **å®Œå…¨æ— é”**ï¼š
   ```rust
   // è¯»æ“ä½œä»ä¸ä½¿ç”¨ CASï¼Œåªæœ‰ load
   let meta = table.meta(i).load(Ordering::Acquire);
   let entry = guard.protect(table.entry(i), Ordering::Acquire);
   ```

2. **å…ƒæ•°æ®åŠ é€Ÿ**ï¼š
   ```rust
   // å…ˆæ£€æŸ¥ 1 å­—èŠ‚çš„ meta (cache-friendly)
   if meta == h2 {
       // åŒ¹é…åæ‰åŠ è½½ 8 å­—èŠ‚çš„æŒ‡é’ˆ
       let entry = guard.protect(...);
   }
   ```

3. **äºŒæ¬¡æ¢æµ‹ä¼˜åŒ–**ï¼š
   ```rust
   // åºåˆ—: i, i+1, i+3, i+6, i+10, ...
   // æ¯”çº¿æ€§æ¢æµ‹æ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§ï¼Œæ¯”éšæœºæ¢æµ‹æ›´å¯é¢„æµ‹
   pub fn next(&mut self, mask: usize) {
       self.len += 1;
       self.i = (self.i + self.len) & mask;
   }
   ```

4. **æ¢æµ‹é™åˆ¶ä¿è¯é«˜è´Ÿè½½å› å­**ï¼š
   ```rust
   // limit = 5 * log2(capacity)
   // æµ‹è¯•æ˜¾ç¤ºå¯è¾¾åˆ° ~85% è´Ÿè½½å› å­
   pub fn limit(capacity: usize) -> usize {
       5 * ((usize::BITS as usize) - (capacity.leading_zeros() as usize) - 1)
   }
   ```

### 4. å†™æ“ä½œå®ç°

**æ ¸å¿ƒå‡½æ•°ç­¾å**ï¼š
```rust
pub fn insert<'g>(
    &self,
    key: K,
    value: V,
    replace: bool,  // true=æ›¿æ¢å·²å­˜åœ¨, false=try_insert
    guard: &'g impl VerifiedGuard,
) -> InsertResult<'g, V>
```

**æ’å…¥æµç¨‹**ï¼ˆä½äº `raw/mod.rs:436-499`ï¼‰ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. é¢„åˆ†é… Entry                                          â”‚
â”‚    let new_entry = Box::into_raw(Box::new(Entry {       â”‚
â”‚        key, value                                       â”‚
â”‚    }))                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. åŠ è½½/åˆå§‹åŒ–è¡¨                                         â”‚
â”‚    let mut table = self.root(guard);                    â”‚
â”‚    if table.is_null():                                  â”‚
â”‚        table = self.init(None);  // å»¶è¿Ÿåˆ†é…             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. æ¢æµ‹å¹¶å°è¯•æ’å…¥                                        â”‚
â”‚    loop probe:                                          â”‚
â”‚      if meta == EMPTY:                                  â”‚
â”‚        // CAS å°è¯•æ’å…¥                                   â”‚
â”‚        match table.entry(i).compare_exchange(           â”‚
â”‚            null, new_entry, AcqRel, Acquire):           â”‚
â”‚          Ok(_): return Inserted(new_entry.value)        â”‚
â”‚          Err(found): goto step 4                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. å¤„ç†é”®å†²çª                                            â”‚
â”‚    if found.key == new_entry.key:                       â”‚
â”‚      if replace:                                        â”‚
â”‚        // CAS æ›¿æ¢å€¼                                     â”‚
â”‚        let old = table.entry(i).compare_exchange(       â”‚
â”‚            found, new_entry, AcqRel, Acquire)           â”‚
â”‚        if success:                                      â”‚
â”‚          defer_retire(old, guard)                       â”‚
â”‚          return Replaced(new_entry.value)               â”‚
â”‚      else:                                              â”‚
â”‚        return Error { current: found.value, ... }       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. è¶…å‡ºæ¢æµ‹é™åˆ¶ â†’ è§¦å‘æ‰©å®¹                               â”‚
â”‚    if probe.len > table.limit:                          â”‚
â”‚      table = self.help_copy(copy_all=true, ...)         â”‚
â”‚      goto step 3  // åœ¨æ–°è¡¨é‡è¯•                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**åŸå­æ›´æ–°æ“ä½œ**ï¼š

```rust
pub fn update<'g, F>(&self, key: K, update: F, guard: &'g impl Guard)
    -> Option<&'g V>
where
    F: Fn(&V) -> V,  // å¿…é¡»æ˜¯çº¯å‡½æ•°ï¼
{
    loop {
        let current = self.get(&key, guard)?;
        let new_value = update(current);  // è®¡ç®—æ–°å€¼

        // CAS å°è¯•æ›¿æ¢
        match table.entry(i).compare_exchange(
            current_ptr,
            Box::into_raw(Box::new(Entry { key, value: new_value })),
            Ordering::AcqRel,
            Ordering::Acquire,
        ) {
            Ok(_) => {
                defer_retire(current_ptr, guard);
                return Some(&new_value);
            }
            Err(_) => continue,  // é‡è¯•
        }
    }
}
```

**å…³é”®ç‰¹æ€§**ï¼š
- âœ… ä½¿ç”¨ CAS ä¿è¯åŸå­æ€§
- âœ… å¤±è´¥æ—¶è‡ªåŠ¨é‡è¯•ï¼ˆä¹è§‚é”ï¼‰
- âš ï¸ `update` å‡½æ•°å¯èƒ½è¢«å¤šæ¬¡è°ƒç”¨ï¼ˆå¿…é¡»æ— å‰¯ä½œç”¨ï¼‰

### 5. å¢é‡æ‰©å®¹æœºåˆ¶ â­æ ¸å¿ƒåˆ›æ–°â­

Papaya æ”¯æŒä¸¤ç§æ‰©å®¹æ¨¡å¼ï¼š

#### 5.1 Blocking æ¨¡å¼

```rust
ResizeMode::Blocking
```

**ç‰¹ç‚¹**ï¼š
- æ‰€æœ‰å†™æ“ä½œé˜»å¡Ÿç›´åˆ°æ‰©å®¹å®Œæˆ
- å¤šä¸ªå†™çº¿ç¨‹å¹¶è¡Œå¤åˆ¶æ¡ç›®
- æ›´é«˜ååé‡ï¼Œä½†æœ‰å»¶è¿Ÿå°–å³°

**é€‚ç”¨åœºæ™¯**ï¼š
- é”®é›†ç¨³å®šï¼ˆå¾ˆå°‘æ‰©å®¹ï¼‰
- å¯¹ååé‡æ•æ„Ÿï¼Œå¯¹å»¶è¿Ÿä¸æ•æ„Ÿ
- ä¾èµ–è¿­ä»£å™¨æ“ä½œè¾ƒå¤š

#### 5.2 Incremental æ¨¡å¼ï¼ˆé»˜è®¤ï¼‰â­

```rust
ResizeMode::Incremental(chunk_size)  // é»˜è®¤ chunk_size = 64
```

**æ ¸å¿ƒæ€æƒ³**ï¼šå†™æ“ä½œå¸®åŠ©å®Œæˆä¸€å°å—æ‰©å®¹å·¥ä½œåå†ç»§ç»­

**å®ç°ç»†èŠ‚**ï¼ˆä½äº `raw/mod.rs:2192-2290`ï¼‰ï¼š

```rust
fn help_copy_incremental(
    &self,
    chunk: usize,        // æ¯æ¬¡å¸®åŠ©å¤åˆ¶çš„æ¡ç›®æ•°
    block: bool,         // æ˜¯å¦é˜»å¡ç›´åˆ°å®Œæˆ
    guard: &impl VerifiedGuard,
) -> Table<Entry<K, V>> {
    let table = self.root(guard);
    let next = table.next_table()?;

    loop {
        // 1. åŸå­å£°æ˜è¦å¤åˆ¶çš„èŒƒå›´
        let copy_start = next.state().claim.fetch_add(chunk, Ordering::Relaxed);

        // 2. å¤åˆ¶è¿™ä¸€å—æ¡ç›®
        let mut copied = 0;
        for i in copy_start..(copy_start + chunk) {
            if i >= table.len() { break; }

            // å¤åˆ¶å•ä¸ªæ¡ç›®
            unsafe { self.copy_at_incremental(i, &table, &next, guard) };
            copied += 1;
        }

        // 3. æ›´æ–°å·²å®Œæˆè®¡æ•°ï¼Œå°è¯•æå‡è¡¨
        if self.try_promote(&table, &next, copied, guard) {
            return next;  // æ‰©å®¹å®Œæˆ
        }

        // 4. å¦‚æœä¸å¼ºåˆ¶é˜»å¡ï¼Œç›´æ¥è¿”å›ï¼ˆè®©åç»­æ“ä½œç»§ç»­å¸®åŠ©ï¼‰
        if !block {
            return next;
        }

        // 5. å¦åˆ™è‡ªæ—‹ç­‰å¾…å…¶ä»–çº¿ç¨‹å®Œæˆ
        // ï¼ˆè§ä¸‹æ–¹ Parker æœºåˆ¶ï¼‰
    }
}
```

**å•æ¡ç›®å¤åˆ¶æµç¨‹**ï¼š

```rust
unsafe fn copy_at_incremental(
    &self,
    i: usize,
    table: &Table<Entry<K, V>>,
    next_table: &Table<Entry<K, V>>,
    guard: &impl VerifiedGuard,
) {
    // æ­¥éª¤ 1: æ ‡è®°ä¸ºæ­£åœ¨å¤åˆ¶ï¼ˆé˜»æ­¢å¹¶å‘ä¿®æ”¹ï¼‰
    let entry = table.entry(i)
        .fetch_or(Entry::COPYING, Ordering::AcqRel)
        .unpack();

    if entry.ptr.is_null() {
        // ç©ºæ§½ä½ï¼Œæ ‡è®°ä¸ºå¢“ç¢‘
        table.meta(i).store(meta::TOMBSTONE, Ordering::Release);
        return;
    }

    // æ­¥éª¤ 2: æ ‡è®°ä¸ºå€Ÿç”¨ï¼ˆç”¨äºå»¶è¿Ÿå›æ”¶ï¼‰
    let new_entry = entry.map_tag(|addr| addr | Entry::BORROWED);

    // æ­¥éª¤ 3: æ’å…¥åˆ°æ–°è¡¨
    unsafe {
        self.insert_copy(new_entry, true, next_table, guard).unwrap();
    }

    // æ­¥éª¤ 4: æ ‡è®°ä¸ºå·²å¤åˆ¶
    let copied = entry.raw.map_addr(|addr|
        addr | Entry::COPYING | Entry::COPIED
    );
    table.entry(i).store(copied, Ordering::SeqCst);

    // æ­¥éª¤ 5: å”¤é†’ç­‰å¾…çš„å†™çº¿ç¨‹
    table.state().parker.unpark(table.entry(i));
}
```

**æå‡è¡¨é€»è¾‘**ï¼š

```rust
fn try_promote(
    &self,
    table: &Table<Entry<K, V>>,
    next: &Table<Entry<K, V>>,
    just_copied: usize,
    guard: &impl VerifiedGuard,
) -> bool {
    // æ›´æ–°å·²å¤åˆ¶è®¡æ•°
    let copied = next.state().copied.fetch_add(just_copied, Ordering::AcqRel)
        + just_copied;

    // æ£€æŸ¥æ˜¯å¦å…¨éƒ¨å®Œæˆ
    if copied < table.len() {
        return false;
    }

    // CAS æ›¿æ¢æ ¹è¡¨æŒ‡é’ˆ
    match self.table.compare_exchange(
        table.raw,
        next.raw,
        Ordering::Release,
        Ordering::Acquire,
    ) {
        Ok(_) => {
            // æ ‡è®°ä¸ºå·²æå‡
            next.state().status.store(State::PROMOTED, Ordering::SeqCst);

            // å”¤é†’æ‰€æœ‰ç­‰å¾…çº¿ç¨‹
            table.state().parker.unpark(&table.state().status);

            // å»¶è¿Ÿå›æ”¶æ—§è¡¨
            guard.defer_retire(table.raw, |table, collector| {
                unsafe { Table::dealloc(Table::from_raw(table)) }
            });

            true
        }
        Err(_) => false,
    }
}
```

**ä¼˜åŠ¿å¯¹æ¯”**ï¼š

| ç‰¹æ€§ | Incremental | Blocking |
|------|-------------|----------|
| å†™å»¶è¿Ÿ | ç¨³å®šï¼ˆP99 ä½ï¼‰ | æœ‰å°–å³° |
| ååé‡ | ä¸­ç­‰ | é«˜ |
| è¯»å¤æ‚åº¦ | å¯èƒ½æŸ¥ä¸¤è¡¨ | åªæŸ¥ä¸€è¡¨ |
| å†…å­˜å³°å€¼ | ä¸¤è¡¨å¹¶å­˜æ—¶é—´é•¿ | ä¸¤è¡¨å¹¶å­˜æ—¶é—´çŸ­ |
| é€‚åˆåœºæ™¯ | å»¶è¿Ÿæ•æ„Ÿ | ååé‡æ•æ„Ÿ |

**åŸºå‡†æµ‹è¯•æ•°æ®**ï¼ˆæ¥è‡ª `BENCHMARKS.md`ï¼‰ï¼š

å»¶è¿Ÿåˆ†å¸ƒå¯¹æ¯”ï¼ˆInsert æ“ä½œï¼‰ï¼š
```
Papaya (Incremental):
  P50:  ~100ns
  P99:  ~500ns
  P99.9: ~2Î¼s

DashMap (Bucket Locks):
  P50:  ~120ns
  P99:  ~50Î¼s   (é«˜ 100 å€!)
  P99.9: ~500Î¼s (é«˜ 250 å€!)
```

### 6. å†…å­˜å›æ”¶æœºåˆ¶ - Seize GC

Papaya ä½¿ç”¨ [seize](https://github.com/ibraheemdev/seize) åº“å®ç°åŸºäº epoch çš„åƒåœ¾å›æ”¶ã€‚

#### 6.1 Guard æœºåˆ¶

```rust
// æœ¬åœ° Guardï¼ˆä¸å¯è·¨çº¿ç¨‹ï¼‰
pub fn pin(&self) -> HashMapRef<'_, K, V, S, LocalGuard<'_>> {
    HashMapRef {
        guard: self.raw.guard(),
        map: self,
    }
}

// æ‹¥æœ‰æ‰€æœ‰æƒçš„ Guardï¼ˆå¯è·¨ .awaitï¼‰
pub fn pin_owned(&self) -> HashMapRef<'_, K, V, S, OwnedGuard<'_>> {
    HashMapRef {
        guard: self.raw.owned_guard(),
        map: self,
    }
}
```

**å·¥ä½œåŸç†**ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Epoch-Based Reclamation (EBR)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Global Epoch: 0 â†’ 1 â†’ 2 â†’ 3 ...                        â”‚
â”‚                                                         â”‚
â”‚  Thread 1: [Guard active, epoch=2]                      â”‚
â”‚            â†“                                            â”‚
â”‚            ä¿æŠ¤ epoch 2 åŠä¹‹å‰çš„å¯¹è±¡                      â”‚
â”‚                                                         â”‚
â”‚  Thread 2: retire(ptr) at epoch=3                       â”‚
â”‚            â†“                                            â”‚
â”‚            ptr åŠ å…¥ epoch 3 çš„å›æ”¶åˆ—è¡¨                    â”‚
â”‚                                                         â”‚
â”‚  å½“æ‰€æœ‰ Guard éƒ½ >= epoch 4:                             â”‚
â”‚            â†“                                            â”‚
â”‚            å›æ”¶ epoch 3 çš„å¯¹è±¡ (ptr)                      â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ç¤ºä¾‹**ï¼š
```rust
let map = HashMap::new();

// çº¿ç¨‹ 1: è¯»æ“ä½œ
{
    let guard = map.pin();  // è¿›å…¥å½“å‰ epoch
    let value = guard.get(&key);
    // value çš„å¼•ç”¨åœ¨ guard ç”Ÿå‘½å‘¨æœŸå†…æœ‰æ•ˆ
} // guard é”€æ¯ï¼Œå¯èƒ½è§¦å‘ epoch æ¨è¿›

// çº¿ç¨‹ 2: å†™æ“ä½œ
{
    let guard = map.pin();
    let old = guard.remove(&key);
    // old è¢«æ ‡è®°ä¸ºå»¶è¿Ÿå›æ”¶ï¼Œç­‰å¾…å®‰å…¨ç‚¹
}
```

#### 6.2 å»¶è¿Ÿå›æ”¶ç­–ç•¥

ä½äº `raw/mod.rs:2568-2610`ï¼š

```rust
unsafe fn defer_retire(
    &self,
    entry: Tagged<Entry<K, V>>,
    table: &Table<Entry<K, V>>,
    guard: &impl VerifiedGuard,
) {
    // æƒ…å†µ 1: éå¢é‡æ¨¡å¼ æˆ– æ¡ç›®æœªè¢«å€Ÿç”¨
    if !self.is_incremental() || !(entry.tag() & Entry::BORROWED) {
        // å¯ä»¥ç«‹å³å»¶è¿Ÿå›æ”¶
        unsafe {
            guard.defer_retire(entry.ptr, seize::reclaim::boxed);
        }
        return;
    }

    // æƒ…å†µ 2: å¢é‡æ¨¡å¼ä¸‹çš„å€Ÿç”¨æ¡ç›®
    let root = self.root(guard);

    if table.raw == root.raw {
        // 2a. å¦‚æœæ˜¯æ ¹è¡¨ï¼Œç«‹å³å›æ”¶
        unsafe {
            guard.defer_retire(entry.ptr, seize::reclaim::boxed);
        }
    } else if let Some(next) = table.next_table() {
        if next.raw == root.raw {
            // 2b. å¦‚æœä¸‹ä¸€ä¸ªè¡¨æ˜¯æ ¹è¡¨ï¼Œç«‹å³å›æ”¶
            unsafe {
                guard.defer_retire(entry.ptr, seize::reclaim::boxed);
            }
        } else {
            // 2c. å¦åˆ™ï¼Œæ¨è¿Ÿåˆ°è¡¨å›æ”¶æ—¶å¤„ç†
            table.state().deferred.push(entry.ptr);
        }
    } else {
        // 2d. æ²¡æœ‰ä¸‹ä¸€ä¸ªè¡¨ï¼Œç«‹å³å›æ”¶
        unsafe {
            guard.defer_retire(entry.ptr, seize::reclaim::boxed);
        }
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦å»¶è¿Ÿå›æ”¶ï¼Ÿ**

```
åœºæ™¯: Table A â†’ Table B â†’ Table C (ä¸‰æ¬¡è¿ç»­æ‰©å®¹)

Entry E ä» A å¤åˆ¶åˆ° B æ—¶æ ‡è®° BORROWED
                â†“
å¦‚æœç«‹å³å›æ”¶ Eï¼Œå¯èƒ½å¯¼è‡´ï¼š
  - Table A ä¸­çš„è¯»æ“ä½œçœ‹åˆ° COPIED æ ‡è®°
  - è½¬å‘ Table B æŸ¥æ‰¾
  - ä½† E å·²è¢«å›æ”¶ ğŸ’¥ Use-After-Free!

è§£å†³æ–¹æ¡ˆ:
  - E åŠ å…¥ A çš„ deferred æ ˆ
  - å½“ A è¢«å›æ”¶æ—¶ï¼Œä¸€èµ·å›æ”¶ E
  - æ­¤æ—¶ A ä¸å¯è¾¾ï¼ŒE ä¹Ÿå¿…ç„¶å®‰å…¨
```

#### 6.3 æ€§èƒ½å¼€é”€

**Guard åˆ›å»ºæˆæœ¬**ï¼š
```rust
// LocalGuard: ~10-20ns (ç±»ä¼¼ uncontended Mutex)
// OwnedGuard: ~50-100ns (éœ€è¦åŸå­æ“ä½œ + å †åˆ†é…)
```

**å»ºè®®**ï¼š
- âœ… å¤ç”¨ Guardï¼ˆåœ¨å¾ªç¯å†…ï¼‰
- âœ… è¯»å¯†é›†æ“ä½œä½¿ç”¨ LocalGuard
- âœ… å¼‚æ­¥åœºæ™¯æ‰ä½¿ç”¨ OwnedGuard
- âŒ é¿å…é¢‘ç¹åˆ›å»º/é”€æ¯ Guard

### 7. æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

#### 7.1 åˆ†ç‰‡è®¡æ•°å™¨

ä½äº `raw/utils/counter.rs`ï¼š

```rust
pub struct Counter(Box<[CachePadded<AtomicIsize>]>);

impl Default for Counter {
    fn default() -> Counter {
        // æ¯ä¸ª CPU æ ¸å¿ƒä¸€ä¸ªåˆ†ç‰‡
        let num_cpus = std::thread::available_parallelism()
            .map(Into::into)
            .unwrap_or(1);

        let shards = (0..num_cpus.next_power_of_two())
            .map(|_| CachePadded::new(AtomicIsize::new(0)))
            .collect();

        Counter(shards)
    }
}

impl Counter {
    // è·å–å½“å‰çº¿ç¨‹çš„åˆ†ç‰‡
    pub fn get(&self, guard: &impl Guard) -> &AtomicIsize {
        let shard = guard.thread_id() & (self.0.len() - 1);
        &self.0[shard].value
    }

    // æ±‡æ€»æ‰€æœ‰åˆ†ç‰‡
    pub fn sum(&self) -> usize {
        self.0.iter()
            .map(|x| x.value.load(Ordering::Relaxed))
            .sum::<isize>()
            .try_into()
            .unwrap_or(0)
    }
}
```

**ä¸ºä»€ä¹ˆéœ€è¦åˆ†ç‰‡ï¼Ÿ**

```
å•ä¸€è®¡æ•°å™¨ï¼ˆä¼ªä»£ç ï¼‰:
  insert() {
      count.fetch_add(1)  // â† æ‰€æœ‰çº¿ç¨‹ç«äº‰è¿™ä¸ªåŸå­å˜é‡
  }

  åœ¨ 32 æ ¸æœºå™¨ä¸Šï¼š
    - æ¯æ¬¡ insert éƒ½å¯¼è‡´ç¼“å­˜å¤±æ•ˆ
    - ååé‡å—é™äºå†…å­˜æ€»çº¿å¸¦å®½
    - å®æµ‹: ~10M ops/s

åˆ†ç‰‡è®¡æ•°å™¨:
  insert(guard) {
      let shard = guard.thread_id() & mask;
      count[shard].fetch_add(1)  // â† æ¯ä¸ªçº¿ç¨‹è®¿é—®è‡ªå·±çš„åˆ†ç‰‡
  }

  åœ¨ 32 æ ¸æœºå™¨ä¸Šï¼š
    - æå°‘ç¼“å­˜å¤±æ•ˆï¼ˆCachePadded é˜²æ­¢ä¼ªå…±äº«ï¼‰
    - è¿‘ä¼¼çº¿æ€§æ‰©å±•
    - å®æµ‹: ~300M ops/s (30 å€æå‡!)
```

**CachePadded é˜²æ­¢ä¼ªå…±äº«**ï¼š

```rust
#[repr(align(128))]  // x86_64 ç¼“å­˜è¡Œå¤§å°
pub struct CachePadded<T> {
    value: T,
}
```

```
æ²¡æœ‰ padding:
  [Shard0][Shard1][Shard2][Shard3] â† å¯èƒ½åœ¨åŒä¸€ç¼“å­˜è¡Œ
   CPU0    CPU1    CPU2    CPU3
   â†“ ä¿®æ”¹ Shard0 å¯¼è‡´æ•´ä¸ªç¼“å­˜è¡Œå¤±æ•ˆï¼Œå½±å“å…¶ä»– CPU

æœ‰ padding:
  [Shard0 + padding][Shard1 + padding][Shard2 + padding]
   CPU0 ç¼“å­˜è¡Œ        CPU1 ç¼“å­˜è¡Œ        CPU2 ç¼“å­˜è¡Œ
   â†“ ä¿®æ”¹ Shard0 åªå½±å“ CPU0 çš„ç¼“å­˜è¡Œ
```

#### 7.2 äºŒæ¬¡æ¢æµ‹åºåˆ—

ä½äº `raw/probe.rs`ï¼š

```rust
pub struct Probe {
    pub i: usize,    // å½“å‰ç´¢å¼•
    pub len: usize,  // æ¢æµ‹é•¿åº¦
}

impl Probe {
    // åˆå§‹åŒ–
    pub fn start(hash: usize, mask: usize) -> Probe {
        Probe {
            i: hash & mask,
            len: 0,
        }
    }

    // ä¸‹ä¸€ä¸ªæ¢æµ‹ä½ç½®
    pub fn next(&mut self, mask: usize) {
        self.len += 1;
        self.i = (self.i + self.len) & mask;
    }
}
```

**æ¢æµ‹åºåˆ—**ï¼ˆcapacity = 16ï¼Œhash = 5ï¼‰ï¼š
```
iâ‚€ = 5
iâ‚ = (5 + 1) & 15 = 6
iâ‚‚ = (6 + 2) & 15 = 8
iâ‚ƒ = (8 + 3) & 15 = 11
iâ‚„ = (11 + 4) & 15 = 15
iâ‚… = (15 + 5) & 15 = 4
...

åºåˆ—: 5 â†’ 6 â†’ 8 â†’ 11 â†’ 15 â†’ 4 â†’ 10 â†’ ...
```

**å¯¹æ¯”å…¶ä»–æ¢æµ‹ç­–ç•¥**ï¼š

| ç­–ç•¥ | å…¬å¼ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|------|
| çº¿æ€§ | `i + 1` | ç¼“å­˜å‹å¥½ | ä¸€æ¬¡èšç°‡ä¸¥é‡ |
| äºŒæ¬¡ | `i + lenÂ²` | å‡å°‘èšç°‡ | å¯èƒ½æ— æ³•éå†å…¨è¡¨ |
| **Papaya äºŒæ¬¡** | `i + len` | å¹³è¡¡ä¸¤è€… | éœ€è¦æ›´å¤šæ¢æµ‹ |
| åŒé‡å“ˆå¸Œ | `i + len*h2` | èšç°‡æœ€å°‘ | è®¡ç®—å¼€é”€å¤§ |

**æ¢æµ‹é™åˆ¶è®¾è®¡**ï¼š

```rust
pub fn limit(capacity: usize) -> usize {
    5 * log2(capacity)
}

// ç¤ºä¾‹:
// capacity=1024 â†’ limit=50
// capacity=65536 â†’ limit=80
```

**ä¸ºä»€ä¹ˆä¸ç”¨æ›´é«˜çš„é™åˆ¶ï¼Ÿ**
```
æ¢æµ‹é™åˆ¶ vs è´Ÿè½½å› å­:
  limit=5*log2(n) â†’ ~85% è´Ÿè½½å› å­
  limit=10*log2(n) â†’ ~95% è´Ÿè½½å› å­

ä½†:
  - æ›´é«˜è´Ÿè½½å› å­ = æ›´å¤šæ¢æµ‹ = æ›´æ…¢æŸ¥æ‰¾
  - æ‰©å®¹åé‡æ–°åˆ†å¸ƒåè€Œæ›´å¿«
  - 5* æ˜¯å®éªŒå¾—å‡ºçš„ç”œç‚¹
```

#### 7.3 Parkerï¼ˆæ¡ä»¶ç­‰å¾…ï¼‰

ä½äº `raw/utils/parker.rs`ï¼š

**æ··åˆè‡ªæ—‹/park ç­–ç•¥**ï¼š

```rust
// åœ¨æ‰©å®¹å®Œæˆæ—¶ç­‰å¾…
for spun in 0.. {
    const SPIN_WAIT: usize = 7;  // è‡ªæ—‹æ¬¡æ•°

    let status = state.status.load(Ordering::Acquire);

    if status == State::PROMOTED {
        return;  // å®Œæˆ
    }

    // åˆæœŸ: æŒ‡æ•°é€€é¿è‡ªæ—‹
    if spun <= SPIN_WAIT {
        for _ in 0..(spun * spun) {
            hint::spin_loop();  // CPU æš‚åœæŒ‡ä»¤
        }
        continue;
    }

    // è¶…æ—¶å: park ç­‰å¾…å”¤é†’
    state.parker.park(&state.status, |status| {
        status == State::PENDING
    });
}
```

**ä¸ºä»€ä¹ˆæ··åˆç­–ç•¥ï¼Ÿ**

```
çº¯è‡ªæ—‹:
  âœ… ä½å»¶è¿Ÿ (~10ns)
  âŒ æµªè´¹ CPU
  é€‚åˆ: æçŸ­ç­‰å¾… (<100ns)

çº¯ park:
  âœ… ä¸æµªè´¹ CPU
  âŒ é«˜å»¶è¿Ÿ (~1-10Î¼sï¼ŒåŒ…æ‹¬ä¸Šä¸‹æ–‡åˆ‡æ¢)
  é€‚åˆ: é•¿æ—¶é—´ç­‰å¾… (>1ms)

æ··åˆç­–ç•¥:
  - å‰ 7 æ¬¡è¿­ä»£è‡ªæ—‹ (0, 1, 4, 9, 16, 25, 36 æ¬¡å¾ªç¯)
  - æ€»è‡ªæ—‹æ—¶é—´ ~100-500ns
  - è¶…æ—¶å park
  âœ… å…¼é¡¾ä¸¤è€…ä¼˜åŠ¿
```

#### 7.4 å…ƒæ•°æ®æ•°ç»„ä¼˜åŒ–

**ä¸¤çº§ç´¢å¼•è®¾è®¡**ï¼š

```rust
struct Table {
    meta: [AtomicU8],        // ç¬¬ä¸€çº§: 8 ä½å…ƒæ•°æ®
    entries: [AtomicPtr<T>], // ç¬¬äºŒçº§: 64 ä½æŒ‡é’ˆ
}
```

**æŸ¥æ‰¾è¿‡ç¨‹**ï¼š

```rust
// æ­¥éª¤ 1: æ£€æŸ¥å…ƒæ•°æ®ï¼ˆ1 å­—èŠ‚ï¼Œç¼“å­˜å‹å¥½ï¼‰
let meta = table.meta(i).load(Ordering::Acquire);
if meta != h2 {
    continue;  // å¿«é€Ÿæ‹’ç»ï¼Œæ— éœ€åŠ è½½æŒ‡é’ˆ
}

// æ­¥éª¤ 2: ä»…åœ¨åŒ¹é…æ—¶åŠ è½½æŒ‡é’ˆï¼ˆ8 å­—èŠ‚ï¼‰
let entry = guard.protect(table.entry(i), Ordering::Acquire);
```

**æ€§èƒ½æ”¶ç›Š**ï¼š

```
å‡è®¾:
  - å“ˆå¸Œè¡¨è´Ÿè½½å› å­ 85%
  - å¹³å‡æ¢æµ‹é•¿åº¦ 3
  - L1 ç¼“å­˜å‘½ä¸­ ~1nsï¼ŒL3 ~10ns

ä¸ä½¿ç”¨å…ƒæ•°æ®:
  3 æ¬¡æ¢æµ‹ Ã— 8 å­—èŠ‚æŒ‡é’ˆåŠ è½½ Ã— 10ns = 30ns

ä½¿ç”¨å…ƒæ•°æ®:
  3 æ¬¡æ¢æµ‹ Ã— 1 å­—èŠ‚ meta åŠ è½½ Ã— 1ns = 3ns
  + 1 æ¬¡æŒ‡é’ˆåŠ è½½ Ã— 10ns = 10ns
  æ€»è®¡: 13ns

åŠ é€Ÿ: ~2.3x
```

## æ€§èƒ½è¯„ä»·

### ä¼˜åŠ¿ âœ…

#### 1. è¯»æ€§èƒ½æå¼º

**æ— é”è¯»å–**ï¼š
```rust
// æ•´ä¸ªè¯»è·¯å¾„æ²¡æœ‰ä»»ä½• CAS æ“ä½œ
pub fn get(&self, key: &K, guard: &impl Guard) -> Option<&V> {
    let meta = table.meta(i).load(Ordering::Acquire);  // åªæœ‰ load
    let entry = guard.protect(table.entry(i), Ordering::Acquire);
    // ...
}
```

**åŸºå‡†æµ‹è¯•**ï¼ˆReadHeavyï¼Œ95% è¯» / 5% å†™ï¼‰ï¼š

| çº¿ç¨‹æ•° | Papaya | DashMap | æå‡ |
|--------|--------|---------|------|
| 1 | 15M ops/s | 12M ops/s | 1.25x |
| 8 | 110M ops/s | 60M ops/s | 1.83x |
| 32 | 380M ops/s | 150M ops/s | **2.53x** |

**çº¿æ€§æ‰©å±•æ€§**ï¼š
```
Papaya è¯»ååé‡ â‰ˆ 12M * æ ¸å¿ƒæ•°
ï¼ˆæ¥è¿‘ç†æƒ³çš„çº¿æ€§æ‰©å±•ï¼‰
```

#### 2. å¯é¢„æµ‹å»¶è¿Ÿ

**å»¶è¿Ÿåˆ†å¸ƒ**ï¼ˆInsert æ“ä½œï¼Œ32 çº¿ç¨‹ï¼‰ï¼š

```
Papaya (Incremental Mode):
  Min:    80ns
  P50:    120ns
  P90:    200ns
  P99:    500ns    â† å…³é”®æŒ‡æ ‡
  P99.9:  2Î¼s
  P99.99: 10Î¼s
  Max:    50Î¼s

DashMap (Bucket Locks):
  Min:    90ns
  P50:    150ns
  P90:    300ns
  P99:    50Î¼s     â† é«˜ 100 å€ï¼
  P99.9:  500Î¼s    â† é«˜ 250 å€ï¼
  P99.99: 5ms      â† é«˜ 500 å€ï¼
  Max:    50ms
```

**ä¸ºä»€ä¹ˆå»¶è¿Ÿç¨³å®šï¼Ÿ**

1. **å¢é‡æ‰©å®¹**ï¼š
   ```
   ä¼ ç»Ÿ HashMap:
     æ’å…¥ â†’ è§¦å‘æ‰©å®¹ â†’ ä¸€æ¬¡æ€§å¤åˆ¶æ‰€æœ‰æ¡ç›® â†’ å»¶è¿Ÿå°–å³° ğŸ“ˆ

   Papaya:
     æ’å…¥ â†’ å¸®åŠ©å¤åˆ¶ 64 ä¸ªæ¡ç›® â†’ å®Œæˆæ’å…¥ â†’ å¹³æ»‘å»¶è¿Ÿ ğŸ“‰
   ```

2. **æ— é”è®¾è®¡**ï¼š
   ```
   DashMap:
     è·å–æ¡¶é” â†’ å¯èƒ½é˜»å¡ï¼ˆç­‰å¾…å…¶ä»–çº¿ç¨‹ï¼‰ â†’ å»¶è¿Ÿä¸å¯é¢„æµ‹

   Papaya:
     CAS å¤±è´¥ â†’ ç«‹å³é‡è¯•ï¼ˆä¸é˜»å¡ï¼‰ â†’ å»¶è¿Ÿå¯é¢„æµ‹
   ```

#### 3. å†…å­˜æ•ˆç‡

**é«˜è´Ÿè½½å› å­**ï¼š
```rust
// Papaya: ~85% (æ¢æµ‹é™åˆ¶ 5*log2(n))
// std::HashMap: ~75%
// DashMap: ~70% (å¤šä¸ªæ¡¶ï¼Œæ¯ä¸ªæ¡¶ç‹¬ç«‹)

ç¤ºä¾‹ (1M entries):
  Papaya:     1M / 0.85 â‰ˆ 1.18M æ§½ä½
  std::HashMap: 1M / 0.75 â‰ˆ 1.33M æ§½ä½
  DashMap:    1M / 0.70 â‰ˆ 1.43M æ§½ä½

å†…å­˜èŠ‚çœ: ~17% vs std, ~21% vs DashMap
```

**å•æ¬¡åˆ†é…**ï¼š
```rust
// Papaya: ä¸€æ¬¡ alloc åŒ…å«æ‰€æœ‰æ•°æ®
let layout = size_of::<TableLayout>()
    + len * size_of::<u8>()      // meta
    + len * size_of::<*mut T>(); // entries

// å¥½å¤„:
// 1. å‡å°‘åˆ†é…å™¨å‹åŠ›
// 2. æ›´å¥½çš„ç¼“å­˜å±€éƒ¨æ€§
// 3. ç®€åŒ–å†…å­˜ç®¡ç†
```

**Epoch-Based GC vs å¼•ç”¨è®¡æ•°**ï¼š
```
Arc<V> (å¼•ç”¨è®¡æ•°):
  - æ¯æ¬¡ clone: åŸå­ fetch_add
  - æ¯æ¬¡ drop: åŸå­ fetch_sub
  - å¼€é”€: ~10-20ns per operation

Papaya (EBR):
  - Guard åˆ›å»º: ~10-20ns (ä¸€æ¬¡æ€§)
  - è¯»æ“ä½œ: 0 é¢å¤–å¼€é”€
  - æ‰¹é‡å›æ”¶: é«˜æ•ˆ

ä¼˜åŠ¿: è¯»å¯†é›†å‹åœºæ™¯ä¸‹å†…å­˜è®¿é—®æ›´å°‘
```

#### 4. API è®¾è®¡ä¼˜é›…

**Pin-based API**ï¼š
```rust
// âœ… Papaya: ç®€æ´ï¼Œæ— éœ€æ‰‹åŠ¨ç®¡ç†é”
let map = HashMap::new();
let value = map.pin().get(&key);

// âŒ DashMap: éœ€è¦å¤„ç† RefMut
let map = DashMap::new();
let mut entry = map.get_mut(&key).unwrap();
*entry = new_value;
// å¿˜è®° drop(entry) å¯èƒ½å¯¼è‡´æ­»é”ï¼
```

**åŸå­æ“ä½œæ›¿ä»£ Entry API**ï¼š
```rust
// âœ… Papaya: åŸå­æ›´æ–°
map.pin().update_or_insert(key, |v| v + 1, 0);

// âŒ std::HashMap: éœ€è¦å¯å˜å¼•ç”¨ï¼ˆä¸å¹¶å‘å®‰å…¨ï¼‰
*map.entry(key).and_modify(|v| *v += 1).or_insert(0);

// âŒ DashMap: éœ€è¦å¤„ç†é”
map.entry(key)
    .and_modify(|v| *v += 1)
    .or_insert(0);
```

**å¼‚æ­¥å‹å¥½**ï¼š
```rust
async fn process(map: Arc<HashMap<i32, String>>) {
    let guard = map.pin_owned();  // OwnedGuard: Send + Sync

    for (key, value) in guard.iter() {
        tokio::fs::write(...).await;  // âœ… å¯ä»¥è·¨ .await
    }
}
```

### åŠ£åŠ¿ âŒ

#### 1. å†™å¯†é›†å‹åœºæ™¯æ€§èƒ½ä¸€èˆ¬

**åŸºå‡†æµ‹è¯•**ï¼ˆExchangeï¼Œ50% è¯» / 50% å†™ï¼‰ï¼š

| çº¿ç¨‹æ•° | Papaya | DashMap | å¯¹æ¯” |
|--------|--------|---------|------|
| 1 | 8M ops/s | 9M ops/s | 0.89x |
| 8 | 45M ops/s | 55M ops/s | 0.82x |
| 32 | 120M ops/s | 150M ops/s | **0.80x** |

**åŸå› åˆ†æ**ï¼š

1. **å†…å­˜åˆ†é…å‹åŠ›**ï¼š
   ```rust
   // æ¯æ¬¡æ’å…¥éƒ½éœ€è¦ Box::new
   let entry = Box::new(Entry { key, value });  // å †åˆ†é…

   // DashMap åˆ™å¤ç”¨æ§½ä½ï¼ˆin-place updateï¼‰
   ```

2. **æ‰©å®¹å¸®åŠ©å¼€é”€**ï¼š
   ```rust
   // Incremental æ¨¡å¼ä¸‹ï¼Œæ¯æ¬¡å†™æ“ä½œå¯èƒ½è§¦å‘
   self.help_copy_incremental(chunk=64, ...);
   // é¢å¤–å¤åˆ¶ 64 ä¸ªæ¡ç›® â†’ å»¶è¿Ÿå¢åŠ 
   ```

3. **GC å‹åŠ›**ï¼š
   ```rust
   // é¢‘ç¹çš„ defer_retire è°ƒç”¨
   guard.defer_retire(old_entry, seize::reclaim::boxed);
   // epoch æ¨è¿› + æ‰¹é‡å›æ”¶çš„å¼€é”€
   ```

#### 2. å†…å­˜å¼€é”€

**åŒå€å…ƒæ•°æ®**ï¼š
```
æ¯ä¸ªæ§½ä½:
  meta:    1 byte   (AtomicU8)
  entry:   8 bytes  (AtomicPtr<T>)

å¯¹æ¯” std::HashMap:
  åªéœ€è¦ 8 bytes (Option<T> æˆ–æŒ‡é’ˆ)

é¢å¤–å¼€é”€: ~12.5% (1 / 8)
```

**æ‰©å®¹æœŸé—´å†…å­˜å³°å€¼**ï¼š
```
Incremental æ¨¡å¼:
  æ—§è¡¨ + æ–°è¡¨åŒæ—¶å­˜åœ¨æ—¶é—´è¾ƒé•¿
  å³°å€¼å†…å­˜ = æ—§è¡¨å¤§å° + æ–°è¡¨å¤§å°

ç¤ºä¾‹ (æ‰©å®¹ 1GB â†’ 2GB):
  å³°å€¼å†…å­˜: 1GB + 2GB = 3GB

Blocking æ¨¡å¼:
  æ‰©å®¹å¿«é€Ÿå®Œæˆï¼Œå³°å€¼æ—¶é—´çŸ­
  ä½†å»¶è¿Ÿå°–å³° ~10-100ms
```

**Guard å†…å­˜å¼€é”€**ï¼š
```rust
// LocalGuard: ~24 bytes (æ ˆåˆ†é…)
// OwnedGuard: ~48 bytes (å †åˆ†é… + Arc)

é•¿æœŸæŒæœ‰ Guard:
  - é˜»æ­¢ GC
  - å†…å­˜æ³„æ¼é£é™©

å»ºè®®: åŠæ—¶é‡Šæ”¾ Guard
```

#### 3. å¤æ‚åº¦é«˜

**ä»£ç è¡Œæ•°å¯¹æ¯”**ï¼š
```
Papaya:
  src/raw/mod.rs:    ~2600 è¡Œ
  src/raw/alloc.rs:  ~230 è¡Œ
  src/raw/probe.rs:  ~44 è¡Œ
  æ€»è®¡:              ~3000 è¡Œæ ¸å¿ƒä»£ç 

DashMap:
  src/lib.rs:        ~1500 è¡Œ

å¤æ‚åº¦: Papaya ~2x DashMap
```

**Unsafe ä»£ç å æ¯”**ï¼š
```rust
// Papaya: å¤§é‡ unsafe ä»£ç å—
// - æŒ‡é’ˆæ ‡è®°/è§£åŒ…
// - å†…å­˜å¸ƒå±€æ“ä½œ
// - defer_retire è°ƒç”¨

// å®¡è®¡éš¾åº¦é«˜ï¼Œæ–°æ‰‹éš¾ä»¥è´¡çŒ®
```

**è°ƒè¯•å›°éš¾**ï¼š
```
å…¸å‹ bug åœºæ™¯:
  1. ABA é—®é¢˜ (CAS å‡æˆåŠŸ)
  2. å†…å­˜é¡ºåºé”™è¯¯ (Ordering ä¸å½“)
  3. æŒ‡é’ˆæ ‡è®°é”™è¯¯ (tag è®¡ç®—é”™è¯¯)
  4. å»¶è¿Ÿå›æ”¶è¿‡æ—© (use-after-free)

éœ€è¦æ·±åšçš„å¹¶å‘ç¼–ç¨‹ç»éªŒ
```

### é€‚ç”¨åœºæ™¯

| åœºæ™¯ | é€‚ç”¨æ€§ | æ¨èæ¨¡å¼ | åŸå›  |
|------|--------|----------|------|
| **è¯»å¯†é›†å‹ç¼“å­˜** | â­â­â­â­â­ | Incremental | æ— é”è¯»ï¼Œçº¿æ€§æ‰©å±• |
| **é…ç½®/å…ƒæ•°æ®å­˜å‚¨** | â­â­â­â­â­ | Blocking | é”®é›†ç¨³å®šï¼Œå¶å°”æ›´æ–° |
| **å¼‚æ­¥è¿è¡Œæ—¶çŠ¶æ€** | â­â­â­â­ | Incremental | OwnedGuard æ”¯æŒè·¨ .await |
| **é«˜å¹¶å‘ Web æœåŠ¡** | â­â­â­â­ | Incremental | å¯é¢„æµ‹å»¶è¿Ÿ |
| **å®æ—¶ç³»ç»Ÿ** | â­â­â­â­ | Incremental | P99 å»¶è¿Ÿä½ |
| **å†™å¯†é›†å‹** | â­â­ | - | ä¸å¦‚ DashMap |
| **å°æ•°æ®é›† (<1000)** | â­â­ | - | å¼€é”€ç›¸å¯¹è¾ƒå¤§ |
| **åµŒå…¥å¼ç³»ç»Ÿ** | â­ | - | å†…å­˜/ä»£ç å¤§å°å¼€é”€ |

**å®é™…åº”ç”¨æ¡ˆä¾‹**ï¼š

1. **Solana åŒºå—é“¾**ï¼š
   ```rust
   // è´¦æˆ·çŠ¶æ€ç¼“å­˜ï¼ˆè¯»å¤šå†™å°‘ï¼‰
   // æ•°ç™¾ä¸‡è´¦æˆ·ï¼ŒæŸ¥è¯¢ QPS > 10M
   pub struct AccountsCache {
       cache: Arc<HashMap<Pubkey, Account>>,
   }
   ```

2. **åˆ†å¸ƒå¼ç¼“å­˜**ï¼š
   ```rust
   // è·¨æœåŠ¡çš„å…ƒæ•°æ®ç¼“å­˜
   // è¦æ±‚ P99 å»¶è¿Ÿ < 1ms
   pub struct MetadataCache {
       data: HashMap<String, Metadata>,
   }
   ```

3. **é…ç½®çƒ­æ›´æ–°**ï¼š
   ```rust
   // å…¨å±€é…ç½®ï¼Œé¢‘ç¹è¯»å–ï¼Œå¶å°”æ›´æ–°
   static CONFIG: LazyLock<HashMap<String, Value>> = ...;
   ```

### ä¸ç«å“å¯¹æ¯”

#### è¯¦ç»†å¯¹æ¯”è¡¨

| ç‰¹æ€§ | Papaya | DashMap | flurry | std::HashMap + RwLock |
|------|--------|---------|--------|----------------------|
| **è¯»æ€§èƒ½** | â­â­â­â­â­<br>å®Œå…¨æ— é” | â­â­â­<br>æ¡¶çº§é” | â­â­â­â­<br>åŸºäº Java ConcurrentHashMap | â­â­<br>è¯»é”ç«äº‰ |
| **å†™æ€§èƒ½** | â­â­â­<br>CAS + GC å¼€é”€ | â­â­â­â­<br>åˆ†ç‰‡é”é«˜æ•ˆ | â­â­â­<br>å¤æ‚ CAS | â­<br>å†™é”ç‹¬å  |
| **å»¶è¿Ÿå¯é¢„æµ‹æ€§** | â­â­â­â­â­<br>å¢é‡æ‰©å®¹ | â­â­<br>é”ç«äº‰ | â­â­â­<br>è¾ƒå¥½ | â­<br>è¯»å†™äº’æ–¥ |
| **API æ˜“ç”¨æ€§** | â­â­â­â­<br>Pin-based | â­â­â­â­â­<br>æœ€æ¥è¿‘ std | â­â­â­<br>è¾ƒå¤æ‚ | â­â­â­â­â­<br>æ ‡å‡† API |
| **å†…å­˜æ•ˆç‡** | â­â­â­<br>åŒå€å…ƒæ•°æ® | â­â­â­â­<br>ç´§å‡‘å¸ƒå±€ | â­â­â­<br>ä¸­ç­‰ | â­â­â­â­â­<br>æœ€ä¼˜ |
| **å¼‚æ­¥æ”¯æŒ** | â­â­â­â­â­<br>OwnedGuard | â­â­â­â­<br>éœ€åŒ…è£… | â­â­<br>è¾ƒå·® | â­â­â­<br>async RwLock |
| **ä»£ç å¤æ‚åº¦** | â­â­<br>~3000 è¡Œ | â­â­â­â­<br>~1500 è¡Œ | â­â­<br>å¤æ‚ | â­â­â­â­â­<br>ç®€å• |
| **ç»´æŠ¤æ´»è·ƒåº¦** | â­â­â­â­<br>æ´»è·ƒ | â­â­â­â­â­<br>éå¸¸æ´»è·ƒ | â­â­â­<br>ä¸€èˆ¬ | â­â­â­â­â­<br>æ ‡å‡†åº“ |

#### æ€§èƒ½åŸºå‡†å¯¹æ¯”

**ReadHeavy (95% è¯» / 5% å†™, 32 çº¿ç¨‹)**ï¼š
```
Papaya:      380M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
DashMap:     150M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
flurry:      200M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
RwLock:       80M ops/s  â–ˆâ–ˆâ–ˆâ–ˆ
```

**Exchange (50% è¯» / 50% å†™, 32 çº¿ç¨‹)**ï¼š
```
Papaya:      120M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
DashMap:     150M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
flurry:      100M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
RwLock:       40M ops/s  â–ˆâ–ˆâ–ˆ
```

**RapidGrow (é¢‘ç¹æ‰©å®¹, 32 çº¿ç¨‹)**ï¼š
```
Papaya (Inc): 90M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Papaya (Blk): 110M ops/s â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
DashMap:      80M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
flurry:       70M ops/s  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
RwLock:       30M ops/s  â–ˆâ–ˆâ–ˆ
```

**å»¶è¿Ÿåˆ†å¸ƒ (P99, Insert, 32 çº¿ç¨‹)**ï¼š
```
Papaya:      500ns   â–ˆ
DashMap:     50Î¼s    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
flurry:      5Î¼s     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
RwLock:      100Î¼s   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
```

#### é€‰æ‹©å»ºè®®

**é€‰æ‹© Papaya å¦‚æœ**ï¼š
- âœ… è¯»æ“ä½œ > 80%
- âœ… å¯¹ P99 å»¶è¿Ÿæ•æ„Ÿ (< 1Î¼s)
- âœ… éœ€è¦å¼‚æ­¥æ”¯æŒ
- âœ… æ•°æ®é›†è¾ƒå¤§ (> 10ä¸‡æ¡ç›®)
- âœ… é•¿æœŸè¿è¡Œï¼Œç¨³å®šè´Ÿè½½

**é€‰æ‹© DashMap å¦‚æœ**ï¼š
- âœ… è¯»å†™æ··åˆ (30-70% è¯»)
- âœ… éœ€è¦æœ€æ¥è¿‘ std::HashMap çš„ API
- âœ… å¯¹ç»å¯¹ååé‡æ•æ„Ÿ
- âœ… ä¸æƒ³å¤„ç† Guard
- âœ… éœ€è¦æˆç†Ÿç¨³å®šçš„æ–¹æ¡ˆ

**é€‰æ‹© RwLock<HashMap> å¦‚æœ**ï¼š
- âœ… ç®€å•åœºæ™¯
- âœ… å†™æ“ä½œæå°‘
- âœ… ä¸éœ€è¦æè‡´æ€§èƒ½
- âœ… é¿å…å¤–éƒ¨ä¾èµ–

## æ€»ç»“

### æ ¸å¿ƒåˆ›æ–°

Papaya é€šè¿‡ä»¥ä¸‹åˆ›æ–°å®ç°äº†è¯»å¯†é›†å‹åœºæ™¯çš„æè‡´æ€§èƒ½ï¼š

1. **æ— é”è¯»å–** â­â­â­â­â­
   - åˆ©ç”¨ epoch-based GC å®ç°å®Œå…¨æ— é˜»å¡çš„è¯»æ“ä½œ
   - é¿å…ä»»ä½•å½¢å¼çš„é”ï¼ˆåŒ…æ‹¬è¯»é”ï¼‰
   - çº¿æ€§æ‰©å±•åˆ°æ•°åä¸ªæ ¸å¿ƒ

2. **å¢é‡æ‰©å®¹** â­â­â­â­â­
   - ä¸šç•Œé¢†å…ˆçš„å¯é¢„æµ‹å»¶è¿Ÿç‰¹æ€§
   - åˆ†æ‘Šæ‰©å®¹æˆæœ¬ï¼Œé¿å…å»¶è¿Ÿå°–å³°
   - P99 å»¶è¿Ÿæ¯” DashMap ä½ 100 å€

3. **äºŒçº§ç´¢å¼•** â­â­â­â­
   - å…ƒæ•°æ®æ•°ç»„ + æŒ‡é’ˆçš„ç²¾å·§è®¾è®¡
   - å‡å°‘å†…å­˜è®¿é—®ï¼Œæé«˜ç¼“å­˜å‘½ä¸­ç‡
   - æŒ‡é’ˆæ ‡è®°å®ç°çŠ¶æ€æœº

4. **åˆ†ç‰‡è®¡æ•°** â­â­â­â­
   - æ¶ˆé™¤é•¿åº¦è®¡æ•°çš„ç«äº‰çƒ­ç‚¹
   - Per-thread åˆ†ç‰‡ + CachePadding
   - è¿‘ä¹é›¶å¼€é”€çš„é•¿åº¦æŸ¥è¯¢

### é€‚ç”¨åœºæ™¯æ€»ç»“

```
è¯»å¯†é›†å‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
(>80% è¯»)                    â”‚
                            â”‚
å»¶è¿Ÿæ•æ„Ÿ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
(P99 < 1Î¼s)                 â”œâ”€â”€> âœ… Papaya (Incremental)
                            â”‚
å¼‚æ­¥ç¯å¢ƒ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
(è·¨ .await)                  â”‚
                            â”‚
å¤§æ•°æ®é›† â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
(>10 ä¸‡æ¡ç›®)


å†™å¯†é›†å‹ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
(<50% è¯»)                    â”‚
                            â”‚
ååé‡ä¼˜å…ˆ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                            â”œâ”€â”€> âœ… DashMap
API ç†Ÿæ‚‰åº¦ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
(ç±»ä¼¼ std)                   â”‚
                            â”‚
æˆç†Ÿç¨³å®š â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä»£ç è´¨é‡è¯„ä»·

**ä¼˜ç‚¹**ï¼š
- âœ… æ³¨é‡Šè¯¦å°½ï¼Œæ¯ä¸ª unsafe ä»£ç å—éƒ½æœ‰å®‰å…¨è¯´æ˜
- âœ… æµ‹è¯•è¦†ç›–ç‡é«˜ï¼ˆåŒ…æ‹¬å¹¶å‘æµ‹è¯•ï¼‰
- âœ… æ–‡æ¡£å®Œå–„ï¼ˆcrate-level + å‡½æ•°çº§ï¼‰
- âœ… éµå¾ª Rust æœ€ä½³å®è·µ
- âœ… é›¶ä¾èµ–ï¼ˆé™¤äº† seize å’Œ equivalentï¼‰

**ç¼ºç‚¹**ï¼š
- âŒ å¤æ‚åº¦é«˜ï¼Œæ–°æ‰‹éš¾ä»¥ç†è§£
- âŒ Unsafe ä»£ç å¤šï¼Œéœ€è¦ä¸“å®¶å®¡è®¡
- âŒ è°ƒè¯•å›°éš¾ï¼ˆå¹¶å‘ bug éš¾ä»¥å¤ç°ï¼‰

**ç»¼åˆè¯„åˆ†**ï¼š

| ç»´åº¦ | è¯„åˆ† | è¯´æ˜ |
|------|------|------|
| **ä»£ç è´¨é‡** | â­â­â­â­â­ | é«˜è´¨é‡ï¼Œæ³¨é‡Šè¯¦ç»† |
| **è¯»æ€§èƒ½** | â­â­â­â­â­ | ä¸šç•Œé¡¶çº§ |
| **å†™æ€§èƒ½** | â­â­â­ | ä¸­ç­‰åä¸Š |
| **å»¶è¿Ÿç¨³å®šæ€§** | â­â­â­â­â­ | é¢†å…ˆç«å“ |
| **å†…å­˜æ•ˆç‡** | â­â­â­ | è‰¯å¥½ |
| **API è®¾è®¡** | â­â­â­â­ | ç®€æ´ä¼˜é›… |
| **åˆ›æ–°æ€§** | â­â­â­â­â­ | å¤šé¡¹åˆ›æ–° |
| **æ˜“ç”¨æ€§** | â­â­â­ | éœ€è¦å­¦ä¹  Guard |
| **æˆç†Ÿåº¦** | â­â­â­â­ | ç”Ÿäº§å¯ç”¨ |

**æ€»ä½“è¯„ä»·**: â­â­â­â­ (4.5/5)

Papaya æ˜¯ä¸€ä¸ª**å·¥ç¨‹è®¾è®¡ä¼˜ç§€**çš„å¹¶å‘å“ˆå¸Œè¡¨å®ç°ï¼Œåœ¨è¯»å¯†é›†å‹åœºæ™¯ä¸‹è¡¨ç°å“è¶Šã€‚å®ƒåœ¨ Solana ç­‰é«˜æ€§èƒ½åŒºå—é“¾é¡¹ç›®ä¸­çš„åº”ç”¨è¯æ˜äº†å…¶ä»·å€¼ã€‚è™½ç„¶å†™å¯†é›†å‹åœºæ™¯è¡¨ç°ä¸€èˆ¬ï¼Œä½†åœ¨å…¶ç›®æ ‡åœºæ™¯ï¼ˆè¯» > 80%ï¼‰ä¸‹ï¼ŒPapaya æ˜¯ Rust ç”Ÿæ€ä¸­æœ€ä½³çš„é€‰æ‹©ä¹‹ä¸€ã€‚

### å­¦ä¹ ä»·å€¼

å¯¹äº Rust å¹¶å‘ç¼–ç¨‹å­¦ä¹ è€…ï¼ŒPapaya æä¾›äº†æä½³çš„å­¦ä¹ æ¡ˆä¾‹ï¼š

1. **Epoch-Based GC å®è·µ** - ç†è§£å¦‚ä½•åœ¨ Rust ä¸­å®ç°å®‰å…¨çš„å¹¶å‘å†…å­˜å›æ”¶
2. **æ— é”æ•°æ®ç»“æ„** - å­¦ä¹  CASã€å†…å­˜é¡ºåºã€ABA é—®é¢˜çš„å¤„ç†
3. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§** - ç¼“å­˜ä¼˜åŒ–ã€åˆ†ç‰‡ã€æŒ‡é’ˆæ ‡è®°ç­‰æŠ€æœ¯
4. **Unsafe Rust** - å¦‚ä½•æ­£ç¡®ä½¿ç”¨ unsafe å¹¶æä¾›å®‰å…¨æŠ½è±¡

**æ¨èé˜…è¯»é¡ºåº**ï¼š
1. `src/lib.rs` - ç†è§£å…¬å…± API
2. `src/map.rs` - å­¦ä¹ ç”¨æˆ·æ¥å£è®¾è®¡
3. `src/raw/alloc.rs` - äº†è§£å†…å­˜å¸ƒå±€
4. `src/raw/probe.rs` - å­¦ä¹ æ¢æµ‹ç®—æ³•
5. `src/raw/mod.rs` (get) - ç†è§£è¯»æ“ä½œ
6. `src/raw/mod.rs` (insert) - ç†è§£å†™æ“ä½œ
7. `src/raw/mod.rs` (resize) - æ·±å…¥å¢é‡æ‰©å®¹

---

## å‚è€ƒèµ„æº

- **æºç ä»“åº“**: https://github.com/ibraheemdev/papaya
- **æ–‡æ¡£**: https://docs.rs/papaya
- **Seize GC**: https://github.com/ibraheemdev/seize
- **åŸºå‡†æµ‹è¯•**: https://github.com/ibraheemdev/papaya/blob/master/BENCHMARKS.md
- **ç›¸å…³è®ºæ–‡**:
  - *Split-Ordered Lists: Lock-Free Extensible Hash Tables* (Shalev & Shavit, 2006)
  - *Epoch-Based Reclamation* (Fraser, 2004)

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ†ææ—¥æœŸ**: 2025-01-17
**Papaya ç‰ˆæœ¬**: 0.2.3
**ä½œè€…**: AI Assistant
